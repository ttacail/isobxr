---
title: "6 - General vignette"
author: "Théo Tacail"
date: "`r Sys.Date()`" 
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{6 - General vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
#####################################################################################
library(devtools)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

----

# Running isobxr box models with `run_isobxr`

## Using `run_isobxr`

We consider the demonstration **isobxr master file** (0_ISOBXR_MASTER.xlsx) stored in the working directory. In the demonstration example, the **isobxr master file** describes an imaginary model. It is designed for the calcium $^{44}Ca/^{42}Ca$ isotope ratios. 

```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./10_ABCD_CONSTANTS.png')
```

The **BOXES** sheet describes a total system composed of 4 finite boxes (A, B, C, D). 
The layout of the boxes in the diagram rendering aims at placing these boxes on the four corners of 10x10 units square.


```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./11_ABCD_BOXES.png')
```
  
We assume that fluxes are expressed in mg of Ca per day, sizes in mg of Ca and run time units will be days.  

The **FLUXES** sheet describes 5 flux lists  

1. *Fx1_ABC_bal* describes a balanced closed system composed of 3 finite boxes A, B and C.   
1. *Fx2_ABC_unbal* describes an unbalanced closed system composed of 3 finite boxes A, B and C.  
1. *Fx3_ABC_unbal* describes an unbalanced closed system composed of 3 finite boxes A, B and C.   
1. *Fx4_ABCD_bal* describes a balanced closed system composed of 4 finite boxes A, B, C and D.     
1. *Fx5_ABCD_unbal*  describes an unbalanced closed system composed of 4 finite boxes A, B, C and D.  

All box sizes are here set at 2000 mg.  
  
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./12_ABCD_FLUXES.png')
```

The **COEFFS** sheet describes 5 lists of fractionation coefficients:

* *a0* describes no isotope fractionation (all $\alpha_{i \to j}$ being equal to one)  
* *a1* describes a system with 1 fractionation coefficient being different from 1:   
    $\alpha_{A \to B} = 0.999$  
* *a2* describes a system with 2 fractionation coefficients being different from 1:  
    $\alpha_{A \to B} = 0.999$, $\alpha_{B \to A} = 1.001$  
* *a3* describes a system with 3 fractionation coefficients being different from 1:  
    $\alpha_{A \to B} = 0.999$, $\alpha_{B \to A} = 1.001$, $\alpha_{C \to A} = 0.9997$  
* *a4* describes a system with 1 fractionation coefficient being different from 1:  
    $\alpha_{C \to D} = 0.99$  
    
**Note**
:    how these lists of coefficients only refer to 4 fractionation coefficients, while the total number of possible box pairs is 16.
     The `run_isobxr` function takes into consideration the documented pairs (both for fluxes and fractionation coefficients), 
     and automatically sets the value of undocumented pairs to the default one (0 for fluxes and 1 for fractionation coefficients).

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./13_ABCD_COEFFS.png')
```

### Balanced 3-boxes closed system model

We consider here the case a balanced closed system of 3 finite boxes (flux list *Fx1_ABC_bal*).  
For this run we use the *a1* fractionation coefficients list.  
We will run this model for a total time of 2500 days with a resolution of 1 calculation every 10 days (250 steps).  

```{r eval=FALSE}
run_isobxr(workdir = "~/1_ABC_tutorial", # isobxr master file work. dir.
           SERIES_ID = "ABC_closed_balanced", # series ID of the set of runs
           flux_list_name = "Fx1_ABC_closed_bal", # which flux list from FLUXES sheet
           coeff_list_name = "a1", # which coefficients list from COEFFS sheet
           t_lim = 2500, # how long do I want to run
           nb_steps = 250, # how many steps over this run duration
           time_units = c("d", "d"), # run time units (days), plot time units (years)
           to_DIGEST_evD_PLOT = TRUE,
           to_DIGEST_CSV_XLS = TRUE,
           to_DIGEST_DIAGRAMS = TRUE) # export plot as pdf
```

The first default outputs of the run are the messages sent by the function on the R console (all of these pieces of information being besides stored in the LOG file).

The `run_isobxr` function therefore choses to run the analytical solver (`ana_slvr`).

In the case of this run we can see the following messages:

```{r echo=FALSE}
"< All boxes are FINITE >"
"< Running ana_slvr (BALANCED FINITE BOXES) > "
```

This is expected since no INFINITE box has been declared and all inward and outward fluxes for each box are expected to be balanced.

The associated pre-run outputs (optional) are the model diagrams of fluxes (left) and of fractionation coefficients (right, expressed as amplitude of isotope fractionation, in ‰). 

```{r echo=FALSE, out.width='47%'}
knitr::include_graphics('./15_ABC_balanced_closed_0001_DIAGf_Fx1_ABC_bal.png')
knitr::include_graphics('./14_ABC_balanced_closed_0001_DIAGa_a1.png')
```

Finally, the post-run output includes the evolution of $\delta$ values over the run duration, shown in years for this run.

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./16_ABC_balanced_closed_0001_plot_evD.png')
```

Note that the run resolution can be seen by the discrete behavior of the evolution of $\delta$ values on the left handside of the logarithmic time scale. 
This display effect would be smoothed out by a higher run resolution (nb_steps = 2500 or 25000 for instance).


### Unbalanced 3-boxes closed system model

We consider here the case of an unbalanced closed system of 3 finite boxes (flux list *Fx2_ABC_unbal*).  
For this run we use the *a1* fractionation coefficients list.  
We will run this model for a total time of 2500 days with a resolution of 1 calculation every 10 days (250 steps).  

```{r eval=FALSE}
run_isobxr(workdir = "~/1_ABC_tutorial", # isobxr master file work. dir.
           SERIES_ID = "ABC_closed_unbalanced", # series ID of the set of runs
           flux_list_name = "Fx2_ABC_closed_unbal", # which flux list from FLUXES sheet
           coeff_list_name = "a1", # which coefficients list from COEFFS sheet
           t_lim = 2500, # how long do I want to run
           nb_steps = 250, # how many steps over this run duration
           time_units = c("d", "d"), # run time units (days), plot time units (years)
           to_DIGEST_evD_PLOT = TRUE,
           to_DIGEST_CSV_XLS = TRUE,
           to_DIGEST_DIAGRAMS = TRUE) # export plot as pdf
```


The first default outputs of the run are the messages sent by the function on the R console (all of these pieces of information being besides stored in the LOG file).

In the case of this run we can see the following messages:

```{r echo=FALSE}
"< All boxes are FINITE >"
"< A IN-OUT BALANCE is pos >" 
"< C IN-OUT BALANCE is neg (max run: 2000 t units) >" 
"< Running num_slvr (UNBALANCED FINITE BOXES) >" 
"*** UPDATED TOTAL RUN TIME *** < Total run time has been changed from 2500 to 2000 (limiting box: C) > "
```

The first message is expected since no INFINITE box has been declared.

The second and third lines point out the fact that boxes A and C are out of balance: A accumulates calcium while C loses calcium. 

The function also tells us that it will take in total 2000 days for the box C to be totally emptied. This is expected since C has a size of 2000 mg and, as can be seen on the flux diagram below, C loses 1 mg of Ca per day.

The `run_isobxr` function therefore choses to run the numerical solver (`num_slvr`).

Finally, the `run_isobxr` function warns the user: it automatically updated the total run time, changing it from 2500 days to 2000 days because the box C would have lost all of its calcium by 2000 days.

The associated pre-run outputs (optional) are the model diagrams of fluxes (left) and of fractionation coefficients (right, expressed as amplitude of isotope fractionation, in ‰). 

```{r echo=FALSE, out.width='47%'}
knitr::include_graphics('./17_ABC_unbalanced_closed_0001_DIAGf_Fx2_ABC_unbal.png')
knitr::include_graphics('./18_ABC_unbalanced_closed_0001_DIAGa_a1.png')
```

Finally, the post-run output includes the evolution of $\delta$ values over the run duration, shown in years for this run.

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./19_ABC_unbalanced_closed_0001_plot_evD.png')
```

Note that in this example, the slight imbalance does not affect the overall bevaviour of the system at time scale when compared to the balanced system.

### Formatting the forcing parameters
#### Forcing initial box sizes

By default, the `run_isobxr` function sets the initial box sizes (mass of element X in each box) 
at the values found in the flux list specified by user.

It is possible to manually overwrite the initial size of one, 
several or all boxes for a given run performed by `run_isobxr`.  
It is done by defining a data frame structured as follows.

```{r echo=TRUE}
FORCING_SIZE <- 
  data.frame(BOXES_ID = c("BOX_1", "...", "BOX_i", "..."),
             SIZE_INIT = c("updated_size_1", "...", "updated_size_i", "..."))

FORCING_SIZE
```

For the 3-boxes closed system model (ABC), in order to change the size of box C from 2000 mg of Ca 
(default as specified in **isobxr master file** for all flux lists of **FLUXES** sheet)
to 3000 mg of Ca, the data frame should be structured as follows:

```{r echo=TRUE}
FORCING_SIZE <- 
  data.frame(BOXES_ID = c("C"),
             SIZE_INIT = c(3000))

FORCING_SIZE
```

#### Forcing initial delta values

By default, the `run_isobxr` function sets the initial delta values of all boxes at 0 ‰.

It is possible to manually overwrite the initial delta values of one, 
several or all boxes for a given run performed by `run_isobxr`.  
It is done by defining a data frame structured as follows.

```{r echo=TRUE}
FORCING_DELTA <- 
  data.frame(BOXES_ID = c("BOX_1", "...", "BOX_i", "..."),
             DELTA_INIT = c("updated_delta_1", "...", "updated_delta_i", "..."))

FORCING_DELTA
```

For the 3-boxes closed system model (ABC), in order to force the fractionation coefficient 
associated to the flux of Ca from box A to B to the value of 1.02,
the data frame should be structured as follows:

```{r echo=TRUE}
FORCING_DELTA <- 
  data.frame(BOXES_ID = c("A"),
             DELTA_INIT = c(-1))

FORCING_DELTA
```

#### Forcing isotope fractionation coefficients

By default, the `run_isobxr` function sets the isotope fractionation coefficients 
at the values found in the coefficients list specified by user.

It is possible to manually overwrite the fractionation coefficients of one, several or all pairs of boxes for a given run performed by `run_isobxr`.  
It is done by defining a data frame structured as follows.

```{r echo=TRUE}
FORCING_ALPHA <- 
  data.frame(FROM = c("BOX_i", "..."),
             TO = c("BOX_j", "..."),
             ALPHA = c("new_coeff_value", "..."),
             FROM_TO = c("BOX_i_BOX_j", "..."))

FORCING_ALPHA
```

For the 3-boxes closed system model (ABC), in order to force the fractionation coefficient 
associated to the flux of Ca from box A to B to the value of 1.02,
the data frame should be structured as follows:

```{r echo=TRUE}
FORCING_ALPHA <- 
  data.frame(FROM = c("A"),
             TO = c("B"),
             ALPHA = c(1.02),
             FROM_TO = c("A_B"))

FORCING_ALPHA
```

#### Forcing fractionation coefficient to a Rayleigh distillation model

It is possible to overwrite isotope fractionation coefficients 
by defining their values as the result of Rayleigh type isotope
distillation in the context of a fractional exchange at an interface. 

We consider here the case of the loss of element X from a box A to a box C through an interface box B, 
all possibly part of a bigger box model system.

We suppose that the apparent fractionation coefficient $\alpha_{A \to C}$ associated to this flux $F_{A \to C}$ 
results from a Rayleigh type distillation occuring during the fractional exchange of element X at the interface box B.

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./20_Rayleigh_distillation_design.png')
```

In this situation, the box A exchanges element X with box B (and possibly other boxes).

This is a fractional exchange, *i.e.* during this exchange, box A sends more of element X to box B than B sends back ($F_{A \to B} > F_{B \to A}$).  

As we consider box B to be balanced, it loses the difference to box C: $F_{B \to C} = F_{A \to B} - F_{B \to A}$.  

As a result, box A loses a total of $F_{B \to C}$ of element X per time unit.  

We suppose here that the $F_{A \to B}$ that feeds box B is associated to no isotope fractionation.  

On the other hand, we suppose that the $F_{B \to A}$ flux corresponding to the fractional loss of element X from interface box B, and returning to box A, 
is associated to an *equilibrium* or *incremental* isotope fractionation ($\alpha^0 _{B \to A}$).

The Rayleigh distillation model of isotopes thus predicts the following: 

$$R_{C} = R_{C, t_0} \dfrac{F_{B \to C}}{F_{A \to B}}^{\alpha^0 _{B \to A} - 1}  $$

The $R_{C, t_0}$ corresponds to the isotope ratio of the element X in box B before any exchange with box A occurs. 
It is thus equivalent to $R_{A}$ since the box B only input is *via* the $F_{A \to B}$ flux.

We thus can write the following definition of $\alpha_{B \to C}$ (equivalent here to $\alpha_{A \to C}$):

$\alpha_{B \to C} = \dfrac{R_{C}}{R_{A}} = \dfrac{F_{B \to C}}{F_{A \to B}}^{\alpha^0 _{B \to A} - 1}$

The `run_isobxr` function here takes as an optional input the data frame structured as follows:

```{r}
FORCING_RAYLEIGH <- 
  data.frame(XFROM = c("B"), # Define the B>C flux at numerator
             XTO = c("C"),
             YFROM = c("A"), # Define the A>B flux at denominator
             YTO = c("B"),
             AFROM = c("B"), # Define the resulting fractionation coefficient
             ATO = c("C"),
             ALPHA_0 = c("a0") # Define the value of incremental B>A coefficient
  ) 

FORCING_RAYLEIGH
```

The `run_isobxr` function will in this case overwrite the value of $\alpha_{B \to C}$ set in **isobxr master file** or using the FORCING_ALPHA parameter. 

Indeed, if the user forced a new value for $\alpha_{B \to C}$ using the FORCING_ALPHA parameter, 
the `run_isobxr` function will prioritize the FORCING_RAYLEIGH parameter. 

It is possible to define several Rayleigh distillation apparent fractionation coefficients in a given model.  
This is done by adding rows to this data frame.

### Dealing with an open system

The user should define a source box and a sink box and declare them in the **BOXES** sheet as INFINITE. 
We give below an example of a run of for an open system.

```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./21a_ABC_balanced_open_BOXES.png')
```

These boxes should have infinite sizes defined in relation to the system scale 
(important for runs with unbalanced finite boxes, which will use the numerical solver). 
In this example, both source and sink box sizes were set at $10^{15}$.

The source box should only be used with outward fluxes to the open system and should not receive any flux from it.

The sink box should only be used with inward fluxes from the open system and should not send any flux to it.

The function call would be the following for a run of 25000 days, with one calculation every 10 days (nb_steps = 2500).  

We use the *Fx6_ABC_open_bal* flux list and the *a1* coefficient list.

```{r eval=FALSE}
run_isobxr(workdir = workdir_ABC, # isobxr master file work. dir.
           SERIES_ID = "ABC_open_balanced", # series ID of the set of runs
           flux_list_name = "Fx3_ABC_open_bal", # which flux list from FLUXES sheet
           coeff_list_name = "a1", # which coefficients list from COEFFS sheet
           t_lim = 25000, # how long do I want to run
           nb_steps = 2500, # how many steps over this run duration
           time_units = c("d", "d"), # run time units (days), plot time units (years)
           to_DIGEST_evD_PLOT = TRUE,
           to_DIGEST_CSV_XLS = TRUE,
           to_DIGEST_DIAGRAMS = TRUE) # export plot as pdf
```

We obtain the following diagrams, where the infinite boxes display a different color. 

```{r echo=FALSE, out.width='47%'}
knitr::include_graphics('./22_ABC_balanced_open_0001_DIAGf_Fx6_ABC_open_bal.png')
knitr::include_graphics('./21_ABC_balanced_open_0001_DIAGa_a1.png')
```

And we finally obtain the following plot of the evolution of $\delta$ values in all finite boxes over time, 
where we observe the relaxation of the system to it's steady state. 

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./23_ABC_balanced_open_0001_plot_evD.png')
```

Note that both infinite boxes are hidden from this graphic representation but the isotope compositions of all boxes - including source and sink - are stored in the output data files.  

While the sink (or waste) box is not informative as such,
the source could have varying/non-zero initial $\delta$ values,
depending on the run parameters, 
used to force the open system. It will be notably of importance for the use of the `compose_isobxr` function, described thereafter.

******************************************************
# Compose isobxr scenarios with `compose_isobxr`
## How does `compose_isobxr` work?

The `compose_isobxr` function allows to perform a series of successive isobxr runs (calling the `run_isobxr` function), 
allowing to build a scenario of composite runs each one 
inheriting the final state of the previous run as its own initial state.

As defined in the documentation, `compose_isobxr` takes a series of inputs from a working directory as well as from the user in the console, 
it stores a track of all the run conditions both in run specific files and in a global LOG file, 
and it returns several outputs files to an automatically created and managed directory and subdirectories.

To find the detailed description of `compose_isobxr` inputs and outputs, refer to its documentation:
```{r eval = FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
# To see documentation on run_isobxr function, type in console:
?compose_isobxr
```

The `compose_isobxr` general principle is shown in following diagram.

```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./29_compo_structure.png')
```

The basic principle of the `compose_isobxr` function lies in the fact that it performs a series of successive runs each of them inheriting from the previous runs final conditions as starting conditions.

The simplest use of the `compose_isobxr` function consists in composing a list of runs with various run duration and resolutions and changing flux lists or coefficients from one run to another. 

For instance, it is possible to run a model of balanced system of finite boxes until total relaxation to steady state followed by a run of the same system in a given unbalanced conformation (different flux list) 
or with a modified set of fractionation coefficients (different coeff list).

Each run will inherit from the previous run final delta values and box sizes and use these as initial values.

It is possible to run the `compose_isobxr` function with various forcing parameters. 

## Format of the *compose master file*

In addition to the global *isobxr master file*, the `compose_isobxr` function
requires a *compose master file*. 

The *compose master file* is the (xlsx) document containing all commands
allowing `compose_isobxr` function to compose a series of runs and build an isobxr scenario.

It is where the user sets the design of their isobxr scenario:

* necessary: define the list of *m* runs composing the scenario (run durations, run resolutions, lists of fluxes, lists of coefficients).  
* optional: define the forcings over one or several runs composing the composite scenario (FORCING_RAYLEIGH, FORCING_ALPHA, FORCING_DELTA, FORCING_SIZE).  

The format of the *compose master file* is standardized. 
The user is encouraged to comply with these standards, as described thereafter, 
otherwise there is a high probability for these functions to crash.


#### **compose master file** name and location

* The *compose master file* is an xlsx file.  
* The *compose master file* name is chose by user and specified in the `compose_isobxr` function inputs: [*e.g.*, **0_COMPO_MASTER.xlsx** ].  
* the *compose master file* should be stored in the directory in which **isobxr master file** is found,
    where all runs for this box model system will be performed and where all outputs will be stored 
    in automatically created subdirectories. This directory corresponds to the working directory (*workdir*) 
    used as parameter of the `compose_isobxr` function.

#### **compose master file structure**

The *compose master file* contains the 5 following sheet strictly named as follows: 

1. **RUN_LIST**: define the list of *m* runs composing the scenario (run durations, run resolutions, lists of fluxes, lists of coefficients).  
1. **FORCING_RAYLEIGH**: define Rayleigh forcings over one or several runs composing the composite scenario.  
1. **FORCING_ALPHA**: define Rayleigh forcings over one or several runs composing the composite scenario.  
1. **FORCING_DELTA**: define initial delta forcings over one or several runs composing the composite scenario.  
1. **FORCING_SIZE**: define initial box size forcings over one or several runs composing the composite scenario.  

#### **RUN_LIST** sheet (*FILLING REQUIRED*)

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./24_COMPO_RUN_LIST.png')
```

The `compose_isobxr` function requires a list of successive *m* runs.

Each of these runs should be succesively described one by one on every row of this sheet, with notably:   

1. the run number (COMPO_RUN_n column)  
1. the run duration (t_lim_list column)  
1. the run resolution (nb_steps_list)  
1. the flux list name (flux_list) that will be read from **isobxr master file**  
1. the coefficients list name (coeff_list) that will be read from **isobxr master file**  

One run should not be described twice.

#### **FORCING_SIZE** sheet (*FILLING OPTIONAL*)

```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./26_COMPO_FORCING_SIZE.png')
```

It is possible to force the initial size of a given run for one or several boxes.

To do so, you need to specify which run the forcing should apply to (COMPO_RUN_n column)  
and the same details as required for the FORCING_SIZE parameter in `run_isobxr` (see previous section).

It is possible to force the local run initial size of several boxes within a given composite run by filling one line per box, with the same COMPO_RUN_n number.

In case no size forcing is required by the user, this sheet should remain with the table headers as such but with empty lines below.

#### **FORCING_DELTA** sheet (*FILLING OPTIONAL*)

```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./27_COMPO_FORCING_DELTA.png')
```

It is possible to force the initial delta values of a given run for one or several boxes.

To do so, you need to specify which run the forcing should apply to (COMPO_RUN_n column)  
and the same details as required for the FORCING_DELTA parameter in `run_isobxr` (see previous section).

It is possible to force the local run initial delta of several boxes within a given composite run by filling one line per box, with the same COMPO_RUN_n number.

In case no delta forcing is required by the user, this sheet should remain with the table headers as such but with empty lines below.

#### **FORCING_ALPHA** sheet (*FILLING OPTIONAL*)

```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./28_COMPO_FORCING_ALPHA.png')
```

It is possible to force the fractionation coefficient values of a given run for one or several pairs of boxes.

To do so, you need to specify which run the forcing should apply to (COMPO_RUN_n column)  
and the same details as required for the FORCING_ALPHA parameter in `run_isobxr` (see previous section).

It is possible to force the local run fractionation coefficients of several pairs of boxes within a given composite run by filling one line per pair of boxes, with the same COMPO_RUN_n number.

In case no alpha forcing is required by the user, this sheet should remain with the table headers as such but with empty lines below.

#### **FORCING_RAYLEIGH** sheet (*FILLING OPTIONAL*)

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./25_COMPO_FORCING_RAYLEIGH.png')
```


It is possible to force the fractionation coefficient to follow a Rayleigh distillation model in a given run for one or several Rayleigh distillation models.

To do so, you need to specify which run the forcing should apply to (COMPO_RUN_n column)  
and the same details as required for the FORCING_RAYLEIGH parameter in `run_isobxr` (see previous section).

It is possible to force the local run fractionation coefficients of several pairs of boxes within a given composite run by filling one line per pair of boxes, with the same COMPO_RUN_n number.

In case no Rayleigh forcing is required by the user, this sheet should remain with the table headers as such but with empty lines below.


## Using `compose_isobxr`


### example #1: perturbating the fluxes  
We compose here the first scenario as described on the screenshot of the *composite master file* used for this run.

```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./30_RUN_LIST_ABC.png')
```

Here, we start with the previous example: a set of 3 finite boxes (A, B, C) consituting an open system interacting with the environment (SOURCE and SINK boxes).

1. We first let the system relax to its' steady-state in a balanced configuration using the *Fx6_ABC_open_bal* flux list for a total of 25000 days (70 years).  
1. We then let the system run with the exact same conditions for 100 days.   
1. We then provoke a disequilibrium by using an unbalanced *Fx7_ABC_open_unbal* flux list (A loses 10 mg of Ca per day, B accumulates 10 mg of Ca per day).  
1. We then let the system relax again with the previous balanced flux configuration (*Fx6_ABC_open_bal*) but with automatically inherited different initial conditions of delta and size values.  

We call the function as follows:

```{r eval=FALSE}
workdir <- "~/1_ABC_tutorial" # isobxr and compo master file work. dir.
SERIES_ID <- "ABC_change_balance" # series ID of the set of compo runs
time_units <- c("d", "d") # time units for run (days) and for plots (years)
COMPO_MASTER <- "0_CPS_MASTER_changing_balance.xlsx" # compo master file name
plot_HIDE_BOXES_delta <- c("SINK") # boxes to hide from evD plot
plot_HIDE_BOXES_size <- c("SOURCE", "SINK") # boxes to hide from evS plot

compose_isobxr(workdir,
               SERIES_ID,
               time_units,
               COMPO_MASTER,
               plot_HIDE_BOXES_delta,
               plot_HIDE_BOXES_size,
               EACH_RUN_DIGEST = TRUE,
               to_CPS_DIGEST_CSVs = TRUE)
```

We obtain the following overviews of the evolution of delta values and box sizes over the run duration. 
By default the plotting functionnality of the `compose_isobxr` function hides initial run of the composite scenario 
because it is usually used as a run to let the system artificially relax to it's steady state.  
Nevertheless, all the data files edited by the function do include the initial run of the composite scenario.

Below is the plot evDS output of both delta and box sizes over time.
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./31_CPS_ABC_change_balance_001_p_evDS.png')
```

Below is the facetted plot evD output of delta values in each box over time.
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./32_CPS_ABC_change_balance_001_pf_evD.png')
```

Below is the facetted plot evS output of box sizes in each box over time.
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./33_CPS_ABC_change_balance_001_pf_evS.png')
```


### example #2: changing the source isotope composition

We consider here the same model example of 3 balanced finite boxes in an open system.

In this case, we leave the same balanced flux configuration for the whole duration of the scenario. 
We also leave the run durations and resolutions unchanged.

```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./35_FORCING_DELTA_ABC_RUN_LIST.png')
```

We however force the delta values of the source box as shown below: 

```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./34_FORCING_DELTA_ABC.png')
```

1. At runs 1 and 2, we leave the source default delta value (0‰).
1. At run 3, we change the source default delta value from 0 to + 0.5 ‰. 
1. At run 4, we change the source delta value bcak to 0‰.

We call the function as follows:

```{r eval=FALSE}
workdir <- workdir_ABC # isobxr and compo master file work. dir.
SERIES_ID <- "ABC_change_source" # series ID of the set of compo runs
time_units <- c("d", "d") # time units for run (days) and for plots (years)
COMPO_MASTER <- "0_CPS_MASTER_changing_source.xlsx" # compo master file name
plot_HIDE_BOXES_delta <- c("SINK") # boxes to hide from evD plot
plot_HIDE_BOXES_size <- c("SOURCE", "SINK") # boxes to hide from evS plot

compose_isobxr(workdir,
               SERIES_ID,
               time_units,
               COMPO_MASTER,
               plot_HIDE_BOXES_delta,
               plot_HIDE_BOXES_size,
               EACH_RUN_DIGEST = TRUE,
               to_CPS_DIGEST_CSVs = TRUE)
```

And for instance, we obtain the following evDS pdf output where we see that the effect of the change in the source isotope composition slightly affects the delta values of A, B and C boxes. 

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./36_0_CPS_ABC_change_source_001_p_evDS.png')
```

******************************************************
# 2D sweep final state with `sweep_steady`

## How does `sweep_steady` work?

The `sweep_steady` function is designed to allow the user to map the combined effects of two parameters over the final state of an [isobxr](https://ttacail.github.io/isobxr/) box model. 

It's structure is shown below: 

```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./37_Sweep_steady_structure.png')
```

The `sweep_steady` function  is built as a 2 steps composite scenario. 

1. The first run (run #1) is used to force the initial conditions of the second run. It is run once only. 

2. The second run (run #2) is repeated for all the combinations of the two parameters values.  
    + Each parameter varies over a range of values defined by the user:  
        - parameter #1 is ranging over *n* values, parameter #2 over *m* values.  
    + Run #2 is repeated over the whole 2D space of parameters ($n \times m$ times).  

The main purpose of this `sweep_steady` structure is:

* to explore the influence of a pair of parameters over the distribution of isotopes in the system at the final state of run #2  
* while starting this run #2 from a common initial state, defined by run #1  
* run #1 typically being for a balanced system, relaxed to it's steady state  



##  Format of the *sweep steady master file*

In addition to the global *isobxr master file*, the `sweep_steady` function
requires a *sweep steady master file*. 

The *sweep steady master file* is the (xlsx) document containing all commands
allowing `sweep_steady` function to compose a scenario of 2 runs. 

The two parameters to be sweeped over run #2 are defined by user directly in the function input, in the R console. 

The format of the *sweep steady master file* is the same as the *compose master file* and the *sweep dynamic master file*.

It is where the user sets the design of their 2 runs scenario to be sweeped:

* necessary: define the list of 2 runs composing the scenario (run durations, run resolutions, lists of fluxes, lists of coefficients).  
* optional: define the forcings over one or both runs composing the composite scenario (FORCING_RAYLEIGH, FORCING_ALPHA, FORCING_DELTA, FORCING_SIZE).  

The format of the *sweep steady master file* is standardized. 
The user is encouraged to comply with these standards, as described thereafter, 
otherwise there is a high probability for these functions to crash.

#### **sweep steady master file** name and location

* The *sweep steady master file* is an xlsx file.  
* The *sweep steady master file* name is chosen by user and specified in the `sweep_steady` function inputs: [*e.g.*, **0_SWEEP_STEADY_MASTER.xlsx** ].  
* the *sweep steady master file* should be stored in the directory in which **isobxr master file** is found, 
    where all runs for this box model system will be performed 
    and where all outputs will be stored in automatically created subdirectories. 
    This directory corresponds to the working directory (*workdir*) used as parameter of the `sweep_steady` function.

#### **sweep steady master file structure**

The *sweep steady master file* contains the 5 following sheet strictly named as follows: 

1. **RUN_LIST**: define the list of 2 runs composing the sweep steady scenario (run durations, run resolutions, lists of fluxes, lists of coefficients).  
1. **FORCING_RAYLEIGH**: define Rayleigh forcings over one or several runs composing the sweep 2 steps scenario.  
1. **FORCING_ALPHA**: define Rayleigh forcings over one or several runs composing the sweep 2 steps scenario.  
1. **FORCING_DELTA**: define initial delta forcings over one or several runs composing the sweep 2 steps scenario.  
1. **FORCING_SIZE**: define initial box size forcings over one or several runs composing the sweep 2 steps scenario.  

#### **RUN_LIST** sheet (*FILLING REQUIRED*)
```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./37_SW_STD_RUN_LIST.png')
```

The `sweep_steady` function strictly requires a list of *2* successive runs.

Both of these runs should be succesively described one by one on two rows of this sheet, with notably:  

1. the run number (COMPO_RUN_n column)  
1. the run duration (t_lim_list column)  
1. the run resolution (nb_steps_list)  
1. the flux list name (flux_list) that will be read from **isobxr master file**  
1. the coefficients list name (coeff_list) that will be read from **isobxr master file**  

#### **FORCING_SIZE** sheet (*FILLING OPTIONAL*)
```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./37_SW_STD_FORCING_SIZE.png')
```

See *composite master file* format description for details.

#### **FORCING_DELTA** sheet (*FILLING OPTIONAL*)
```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./37_SW_STD_FORCING_DELTA.png')
```

See *composite master file* format description for details.

#### **FORCING_ALPHA** sheet (*FILLING OPTIONAL*)
```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./37_SW_STD_ALPHA.png')
```

See *composite master file* format description for details.

#### **FORCING_RAYLEIGH** sheet (*FILLING OPTIONAL*)
```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./37_SW_STD_FORCING_RAYLEIGH.png')
```

See *composite master file* format description for details.

##  Using `sweep_steady`

### Preparing the *sweep steady master* file

The user needs to define the two runs composing the 2 steps scenario. 

1. The first run is used to let the system relax to its steady state used as an initial state in run #2.  
    i) The user should consider here a balanced system. The [isobxr](https://ttacail.github.io/isobxr/) functions will thus use the analytical solver (`ana_slvr`).
    i) We thus recommand the user to set the number of steps for run #1 (nb_steps) to 1 (its' minimum value).  
        This allows to only calculate the final state of the system, at the end of run #1.  
        This reduces the calculation time and data produced without affecting the accuracy of the calculation.  

1. The second run is used to explore the final state of the system as a function of all combinations of parameters #1 and #2 values. 
    i) The main purpose of this function is to explore the influence of the 2 combined parameters over the final state of a system that relaxed to it's steady state. 
    i) It is therefore recommended to use the same balanced system over the second run, allowing to analytically solve the system (with `ana_slvr`).
    i) The use of the analytical solver will notably allow to map the final state at a high resolution of parameters #1 and #2  
        while minimizing the required calculation time as well as RAM and hard memory.  
    i) We thus recommand the user to set the number of steps for run #2 (nb_steps) to 1 (its' minimum value).  
        This allows to only calculate the final state of the system, at the end of run #2.  
        This reduces the calculation time and data produced without affecting the accuracy of the calculation.  
        
**remark**  
:    The reason why the `sweep_steady` function begins with a run #1 which final state defines a common initial state for all repeated run #2 sweeps 
    is that it can allow the user to sweep the final state of a system in the course transient/dynamic state of run #2, being in a balanced or unbalanced system. 
    This needs however to be designed with care as depending on the defined or forced parameters on run #2 vs. run #1, 
    the continuity of the conditions of run #1 and run #2 is not certain. It is then advised to use the better suited `sweep_dyn` function described thereafter.

**Forcings**   
:    The user can define some forcings over the system (will affect both run #1 and run #2).  
    These forcings will overwrite the conditions set by the reading of the *isobxr master file*.  
    These forcings will be overwritten by the sweeped parameters that affect run #2.



### `sweep_steady` console defined sweep parameters
In addition to all the usual input parameters required for the `sweep_steady` function, the user has to define the two parameters to be sweeped.

There are 6 types of sweepable parameters (or that can be explored), which names are strictly defined as follows:


```{r echo=FALSE}
# explore a series of flux lists as defined in isobxr master file
"EXPLO_n_FLUX_MATRICES" 

# explore a series of coeff lists as defined in isobxr master file
"EXPLO_n_ALPHA_MATRICES" 

# explore a vector of sizes for a given box 
"EXPLO_1_SIZE" 

# explore a vector of delta values for a given box 
"EXPLO_1_DELTA" 

# explore a vector of alpha (coeff) values for a given flux
"EXPLO_1_ALPHA" 

# explore a vector of incremental alpha values for a Rayleigh distillation model
"EXPLO_1_RAYLEIGH_ALPHA" 

```


#### **EXPLO_n_FLUX_MATRICES**: 

This type of parameter allows to explore a series of flux lists as defined in *isobxr master file*.

```{r echo=TRUE, results = "hide"}
data.frame(VALUES = c("flux_list_1",  # vector of n strings of characters
                      "...", 
                      "flux_list_i", 
                      "...", 
                      "flux_list_n"),  
           EXPLO_TYPES = "EXPLO_n_FLUX_MATRICES") # stricly leave as such

```

The **EXPLO_n_FLUX_MATRICES** parameter will allow the `sweep_steady` function to sweep the effect of a series of flux lists 
(defining flux matrices and initial box sizes) on run #2 evolution.

The format of this data frame should be exactly as shown above. 

The values are a vector of strings of characters containing the list of flux list names, 
that will be called from the *isobxr master file*

#### **EXPLO_n_ALPHA_MATRICES**: 

This type of parameter allows to explore a series of lists of coefficients as defined in *isobxr master file*.

```{r echo=TRUE, results = "hide"}
data.frame(VALUES = c("coeff_list_1", # vector of n strings of characters
                      "...", 
                      "coeff_list_i", 
                      "...", 
                      "coeff_list_n"), 
           EXPLO_TYPES = "EXPLO_n_ALPHA_MATRICES") # stricly leave as such


```

The **EXPLO_n_ALPHA_MATRICES** parameter will allow the `sweep_steady` function to sweep the effect of a series of isotope fractionation coefficient lists 
(defining coefficient matrices) on run #2 evolution.

The format of this data frame should be exactly as shown above. 

The values are a vector of strings of characters containing the list of coefficients list names, 
that will be called from the *isobxr master file*

#### **EXPLO_1_SIZE**: 

This type of parameter allows to explore a range of sizes for a given box.

```{r echo=TRUE, results = "hide"}
data.frame(BOXES_ID = "BOX_i", # 1 string of char
           SIZE_MIN = "min_sweep_value", # 1 numerical value
           SIZE_MAX = "max_sweep_value", # 1 numerical value
           SIZE_STEPS = "sweep_steps", # 1 numerical value
           EXPLO_TYPES = "EXPLO_1_SIZE") # stricly leave as such


```

The **EXPLO_1_SIZE** parameter will allow the `sweep_steady` function to sweep the effect of a range of box sizes for a given box
on run #2 evolution.

The format of this data frame should be exactly as shown above. 

#### **EXPLO_1_DELTA**: 

This type of parameter allows to explore a range of delta values for a given box.

```{r echo=TRUE, results = "hide"}
data.frame(BOXES_ID = "BOX_i", # 1 string of char
           DELTA_MIN = "min_sweep_value", # 1 numerical value
           DELTA_MAX = "max_sweep_value", # 1 numerical value
           DELTA_STEPS = "sweep_steps", # 1 numerical value
           EXPLO_TYPES = "EXPLO_1_DELTA") # stricly leave as such


```

#### **EXPLO_1_ALPHA**: 

This type of parameter allows to explore a range of alpha (coeff) values for a given flux.

```{r echo=TRUE, results = "hide"}
data.frame(FROM = "BOX_i", # 1 string of char
           TO = "BOX_j", # 1 string of char
           ALPHA_MIN = "min_sweep_value", # 1 numerical value
           ALPHA_MAX = "max_sweep_value", # 1 numerical value
           ALPHA_STEPS = "sweep_steps", # 1 numerical value
           EXPLO_TYPES = "EXPLO_1_ALPHA") # stricly leave as such


```

#### **EXPLO_1_RAYLEIGH_ALPHA**: 

This type of parameter allows to explore a range of incremental alpha values for a Rayleigh distillation model.

```{r echo=TRUE, results = "hide"}
data.frame(XFROM = "Box_B", # B>C flux at numerator (strings of char)
           XTO = "Box_C",
           YFROM = "Box_A", # A>B flux at denominator (strings of char)
           YTO = "Box_B",
           AFROM = "Box_B", # resulting fract. coefficient (strings of char)
           ATO = "Box_C",
           ALPHA_0_MIN = "min_sweep_value", # value of incremental B>A coeff. (num.)
           ALPHA_0_MAX = "max_sweep_value", 
           ALPHA_0_STEPS = "sweep_steps",
           EXPLO_TYPES = "EXPLO_1_RAYLEIGH_ALPHA") # stricly leave as such


```


******************************************************

### Example: sweeping two fractionation coefficients in a 3-boxes balanced open system

Here:

* using the *sweep steady master file* provided for demonstration (0_EXPLO_STEADY_MASTER_demo1.xlsx)
* we perform a sweep of the $\alpha _{C \to B}$ values and $\alpha _{A \to C}$ values at steady state of run #2  
* starting from a run #1 at steady state obtained by the relaxation of the system with the *a1* coefficients list and the *Fx6_ABC_open_bal* flux list 

No forcings are applied. 

To do so, the `sweep_steady` function can be used as follows: 

```{r eval=FALSE, include=TRUE}
workdir <- "~/1_ABC_tutorial" # isobxr and compo master file work. dir.
SERIES_ID <- "ABC_sweep_steady_demo1" # series ID of the set of compo runs
time_units <- c("d", "d") # time units for run (days) and for plots (years)
EXPLO_MASTER <- "0_SWEEP_STD_MASTER.xlsx" # compo master file name

EXPLO_AXIS_1 <- data.frame(FROM = c("C"),
                           TO = c("B"),
                           ALPHA_MIN = 1,
                           ALPHA_MAX = 1.0005,
                           ALPHA_STEPS = 0.00005,
                           EXPLO_TYPES = "EXPLO_1_ALPHA")

EXPLO_AXIS_2 <- data.frame(FROM = c("A"),
                           TO = c("C"),
                           ALPHA_MIN = 0.9996,
                           ALPHA_MAX = 1,
                           ALPHA_STEPS = 0.00005,
                           EXPLO_TYPES = "EXPLO_1_ALPHA")

sweep_steady(workdir,
             SERIES_ID,
             time_units,
             EXPLO_MASTER,
             EXPLO_AXIS_1,
             EXPLO_AXIS_2,
             to_STD_DIGEST_CSVs = T)
```

You can explore the outputs by then using the [isobxr](https://ttacail.github.io/isobxr/) Shiny app (`runShinyPlots` function, presented below).

************************************************
# 2D sweep dynamic response with `sweep_dyn`

## How does `sweep_dyn` work?

The `sweep_dyn` function is designed to allow the user to map the combined effects of two parameters over the dynamic response of an [isobxr](https://ttacail.github.io/isobxr/) box model, 
typically in a system at steady state suddenly facing a perturbation. 

It's structure is shown below: 

```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./38_Sweep_dyn_structure.png')
```

The `sweep_dyn` function  is built as a 2 steps composite scenario. 

1. The first run (run #1) is used to force the initial conditions of the second run. It is run repeatedly together with run #2 over the whole space of parameters defined by user. 
1. The second run (run #2) takes system final state of the run #2 as initial state. It is run repeatedly together with run #1 over the whole space of parameters defined by user. 
1. Both runs (#1 and #2) are repeated together for all the combinations of the two parameters values.  
    + Each parameter varies over a range of values defined by the user:  
        - parameter #1 is ranging over *n* values, parameter #2 over *m* values.  
    + Run #1 and #2 are repeated over the whole 2D space of parameters ($n \times m$ times).  

The main purpose of this `sweep_dyn` structure is:

* to explore the influence of a pair of parameters over the dynamic evolution during run #2 of isotope compositions (and box sizes) in all boxes,
* while starting this run #2 from a an initial state defined by run #1 that also depends on the sweeped parameters
* run #1 typically being for a balanced system, relaxed to it's steady state  

##  Format of the *sweep dyn master file*

In addition to the global *isobxr master file*, the `sweep_dyn` function
requires a *sweep dyn master file*. 

The *sweep dyn master file* is the (xlsx) document containing all commands
allowing `sweep_dyn` function to compose a scenario of 2 runs. 

The two parameters to be sweeped over run #1 and #2 are defined by user directly in the function input, in the R console. 

The format of the *sweep dyn master file* is the same as the *compose master file* and the *sweep steady master file*.

It is where the user sets the design of their 2 runs scenario to be sweeped:

* necessary: define the list of 2 runs composing the scenario (run durations, run resolutions, lists of fluxes, lists of coefficients).  
* optional: define the forcings over one or both runs composing the scenario (FORCING_RAYLEIGH, FORCING_ALPHA, FORCING_DELTA, FORCING_SIZE).  

The format of the *sweep dyn master file* is standardized. 
The user is encouraged to comply with these standards, as described thereafter, 
otherwise there is a high probability for these functions to crash.

#### **sweep dyn master file** name and location

* The *sweep dyn master file* is an xlsx file.  
* The *sweep dyn master file* name is chosen by user and specified in the `sweep_dyn` function inputs: [*e.g.*, **0_SWEEP_DYN_MASTER.xlsx** ].  
* the *sweep dyn master file* should be stored in the directory in which **isobxr master file** is found, 
    where all runs for this box model system will be performed 
    and where all outputs will be stored in automatically created subdirectories. 
    This directory corresponds to the working directory (*workdir*) used as parameter of the `sweep_dyn` function.

#### **sweep dyn master file structure**

The *sweep dyn master file* contains the 5 following sheet strictly named as follows: 

1. **RUN_LIST**: define the list of 2 runs composing the sweep dyn scenario (run durations, run resolutions, lists of fluxes, lists of coefficients).  
1. **FORCING_RAYLEIGH**: define Rayleigh forcings over one or several runs composing the sweep 2 steps scenario.  
1. **FORCING_ALPHA**: define Rayleigh forcings over one or several runs composing the sweep 2 steps scenario.  
1. **FORCING_DELTA**: define initial delta forcings over one or several runs composing the sweep 2 steps scenario.  
1. **FORCING_SIZE**: define initial box size forcings over one or several runs composing the sweep 2 steps scenario.  

#### **RUN_LIST** sheet (*FILLING REQUIRED*)
```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./37_SW_STD_RUN_LIST.png')
```

The `sweep_dyn` function strictly requires a list of *2* successive runs.

Both of these runs should be succesively described one by one on two rows of this sheet, with notably:  

1. the run number (COMPO_RUN_n column)  
1. the run duration (t_lim_list column)  
1. the run resolution (nb_steps_list)  
1. the flux list name (flux_list) that will be read from **isobxr master file**  
1. the coefficients list name (coeff_list) that will be read from **isobxr master file**  

#### **FORCING_SIZE** sheet (*FILLING OPTIONAL*)
```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./37_SW_STD_FORCING_SIZE.png')
```

See *composite master file* format description for details.

#### **FORCING_DELTA** sheet (*FILLING OPTIONAL*)
```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./37_SW_STD_FORCING_DELTA.png')
```

See *composite master file* format description for details.

#### **FORCING_ALPHA** sheet (*FILLING OPTIONAL*)
```{r echo=FALSE, out.width='50%'}
knitr::include_graphics('./37_SW_STD_ALPHA.png')
```

See *composite master file* format description for details.

#### **FORCING_RAYLEIGH** sheet (*FILLING OPTIONAL*)
```{r echo=FALSE, out.width='75%'}
knitr::include_graphics('./37_SW_STD_FORCING_RAYLEIGH.png')
```

See *composite master file* format description for details.

##  Using `sweep_dyn`

### Preparing the *sweep dyn master* file

The user needs to define the two runs composing the 2 steps scenario. 

1. The first run is typically used to let the system relax to its steady state used as an initial state in run #2.  
    i) The user should consider here a balanced system. The [isobxr](https://ttacail.github.io/isobxr/) functions will thus use the analytical solver (`ana_slvr`).
    i) We thus recommand the user to set the number of steps for run #1 (nb_steps) to 1 (its' minimum value).  
        This allows to only calculate the final state of the system, at the end of run #1.  
        This reduces the calculation time and data produced without affecting the accuracy of the calculation.  

1. The second run is used to explore the dynamic response of the system in the face of a given **perturbation**, as a function of all combinations of parameters #1 and #2 values. 
    i) The main purpose of this function is to explore the influence of the 2 combined parameters over the time dependent response of a system that previously relaxed to it's steady state. 
    i) The user has the choice to define a balanced or an unbalanced system in the run #2. 
        A. The latter case (unbalanced system) could here constitute the perturbation of the system. The `sweep_dyn` function will here numerically solve the run #2 (`num_slvr`).
        A. In the case of a balanced system for run #2, the `sweep_dyn` function will analytically solve the run #2 (`ana_slvr`). 
        A. The user should here be aware that the sweeping of the space of parameters using either the `num_slvr` or `ana_slvr` can be time consuming and require a fair bit of calculating power.  
            The user is advised to wisely define the space of parameters (which will define the number of $n \times m$ iterations) as well as the run resoluion of run #2 (nb_steps).

**remark**  
:    The reason why the `sweep_dyn` function sweeps both initial run #1 and run #2 
    is that the user might want to sweep parameters that are actually affecting the steady state of the system (e.g., sweep a series of lists of fluxes or coefficients). 
    
**Forcings**   
:    The user can define some forcings over the system (will affect both run #1 and run #2).  
    These forcings will overwrite the conditions set by the reading of the *isobxr master file*.  
    These forcings will be overwritten by the sweeped parameters that affect run #1 and #2.

### `sweep_dyn` console defined sweep parameters

In addition to all the usual input parameters required for the `sweep_dyn` function, the user has to define the two parameters to be sweeped.

There are 6 types of sweepable parameters (or that can be explored), which names are strictly defined as follows:

```{r echo=FALSE}
# explore a series of flux lists as defined in isobxr master file
"EXPLO_n_FLUX_MATRICES" 

# explore a series of coeff lists as defined in isobxr master file
"EXPLO_n_ALPHA_MATRICES" 

# explore a vector of sizes for a given box 
"EXPLO_1_SIZE" 

# explore a vector of delta values for a given box 
"EXPLO_1_DELTA" 

# explore a vector of alpha (coeff) values for a given flux
"EXPLO_1_ALPHA" 

# explore a vector of incremental alpha values for a Rayleigh distillation model
"EXPLO_1_RAYLEIGH_ALPHA" 

```

#### **EXPLO_n_FLUX_MATRICES**: 

This type of parameter allows to explore two series of flux lists as defined in *isobxr master file*, one for run #1 and one for run #2.

```{r echo=TRUE, results = "hide"}
data.frame(VALUES_1 = c("flux_list_1",  # RUN #1 vector of n strings of chars.
                        "...", 
                        "flux_list_i", 
                        "...", 
                        "flux_list_n"),  
           VALUES_2 = c("flux_list_1",  # RUN #2 vector of n strings of chars.
                        "...", 
                        "flux_list_i", 
                        "...", 
                        "flux_list_n"),  
           EXPLO_TYPES = "EXPLO_n_FLUX_MATRICES") # stricly leave as such

```

The **EXPLO_n_FLUX_MATRICES** parameter will allow the `sweep_dyn` function to sweep the effect 
of two series of flux lists 
(defining flux matrices and initial box sizes) on run #1 and run #2 evolutions.

The format of this data frame should be exactly as shown above. 

The values are two vectors of strings of characters containing the list of flux list names, 
that will be called from the *isobxr master file*.

#### **EXPLO_n_ALPHA_MATRICES**: 

This type of parameter allows to explore two series of lists of coefficients as defined in *isobxr master file*, one for run #1 and one for run #2.

```{r echo=TRUE, results = "hide"}
data.frame(VALUES_1 = c("coeff_list_1", # RUN #1 vector of n strings of chars.
                        "...", 
                        "coeff_list_i", 
                        "...", 
                        "coeff_list_n"), 
           VALUES_2 = c("coeff_list_1", # RUN #2 vector of n strings of chars.
                        "...", 
                        "coeff_list_i", 
                        "...", 
                        "coeff_list_n"), 
           EXPLO_TYPES = "EXPLO_n_ALPHA_MATRICES") # stricly leave as such


```

The **EXPLO_n_ALPHA_MATRICES** parameter will allow the `sweep_dyn` function to sweep the effect 
of two series of isotope fractionation coefficient lists 
(defining coefficient matrices) on run #1 and run #2 evolutions.

The format of this data frame should be exactly as shown above. 

The values are two vectors of strings of characters containing the list of coefficients list names, 
that will be called from the *isobxr master file*.

#### **EXPLO_1_SIZE**: 

This type of parameter allows to explore a range of sizes for a given box over both run #1 and run #2.

This parameter should be used only in the case where RUN #1 is balanced since it sets the initial box size for each run initial condition.

```{r echo=TRUE, results = "hide"}
data.frame(BOXES_ID = "BOX_i", # 1 string of char
           SIZE_MIN = "min_sweep_value", # 1 numerical value
           SIZE_MAX = "max_sweep_value", # 1 numerical value
           SIZE_STEPS = "sweep_steps", # 1 numerical value
           EXPLO_TYPES = "EXPLO_1_SIZE") # stricly leave as such


```

The **EXPLO_1_SIZE** parameter will allow the `sweep_dyn` function to sweep the effect of a range of box sizes for a given box
on run #1 and #2 evolution.

The format of this data frame should be exactly as shown above. 

#### **EXPLO_1_DELTA**: 

This type of parameter allows to explore a range of delta values for a given box over both run #1 and run #2.

This parameter should be used only for source boxes, since it will force the initial isotope composition of this box for both run #1 and run #2.

```{r echo=TRUE, results = "hide"}
data.frame(BOXES_ID = "BOX_i", # 1 string of char
           DELTA_MIN = "min_sweep_value", # 1 numerical value
           DELTA_MAX = "max_sweep_value", # 1 numerical value
           DELTA_STEPS = "sweep_steps", # 1 numerical value
           EXPLO_TYPES = "EXPLO_1_DELTA") # stricly leave as such


```

#### **EXPLO_1_ALPHA**: 

This type of parameter allows to explore a range of alpha (coeff) values for a given flux over both run #1 and run #2.

```{r echo=TRUE, results = "hide"}
data.frame(FROM = "BOX_i", # 1 string of char
           TO = "BOX_j", # 1 string of char
           ALPHA_MIN = "min_sweep_value", # 1 numerical value
           ALPHA_MAX = "max_sweep_value", # 1 numerical value
           ALPHA_STEPS = "sweep_steps", # 1 numerical value
           EXPLO_TYPES = "EXPLO_1_ALPHA") # stricly leave as such


```

#### **EXPLO_1_RAYLEIGH_ALPHA**: 

This type of parameter allows to explore a range of incremental alpha values for a Rayleigh distillation model for both run #1 and run #2. 
It is calculated for each run using the run's local flux configuration.

```{r echo=TRUE, results = "hide"}
data.frame(XFROM = "Box_B", # B>C flux at numerator (strings of char)
           XTO = "Box_C",
           YFROM = "Box_A", # A>B flux at denominator (strings of char)
           YTO = "Box_B",
           AFROM = "Box_B", # resulting fract. coefficient (strings of char)
           ATO = "Box_C",
           ALPHA_0_MIN = "min_sweep_value", # value of incremental B>A coeff. (num.)
           ALPHA_0_MAX = "max_sweep_value", 
           ALPHA_0_STEPS = "sweep_steps",
           EXPLO_TYPES = "EXPLO_1_RAYLEIGH_ALPHA") # stricly leave as such


```


******************************************************
### Example: dynamic sweeping of the size of box B and one fractionation coefficient in a 3-boxes balanced open system after a change in the source isotope composition

Both run #1 and run #2 are performed with the *a1* coefficients list, the *Fx6_ABC_open_bal* flux list and the sweeping paramaters. 

The system faces a perturbation: the source isotope composition is shifted from 0 to -1 ‰ using the FORCING_DELTA sheet of the *sweeping dynamic master file*.

Here: 

* using the *sweep dynamic master file* provided for demonstration (0_EXPLO_DYN_MASTER_demo1.xlsx)  
* we perform a sweep of the box B size values and $\alpha _{A \to C}$ values  
* during the first 1000 days of run #2  
* starting from a run #1 at steady state obtained by the relaxation of the system 

No forcings other than the FORCING_DELTA on the SOURCE box are applied. 

To do so, the `sweep_steady` function can be used as follows: 

```{r eval=FALSE, include=TRUE}
workdir <- "~/1_ABC_tutorial" # isobxr and compo master file work. dir.
SERIES_ID <- "ABC_change_source_sweep_dyn_demo1" # series ID of the set of compo runs
time_units <- c("d", "d") # time units for run (days) and for plots (years)
EXPLO_MASTER <- "0_SWEEP_DYN_MASTER.xlsx" # compo master file name

EXPLO_AXIS_1 <- data.frame(FROM = c("A"),
                           TO = c("C"),
                           ALPHA_MIN = 0.9988,
                           ALPHA_MAX = 1,
                           ALPHA_STEPS = 0.0004,
                           EXPLO_TYPES = "EXPLO_1_ALPHA")

EXPLO_AXIS_2 <- data.frame(BOXES_ID = c("B"),
                           SIZE_MIN = 1500,
                           SIZE_MAX = 2500,
                           SIZE_STEPS = 250,
                           EXPLO_TYPES = "EXPLO_1_SIZE")

sweep_dyn(workdir,
          SERIES_ID,
          time_units,
          EXPLO_MASTER,
          EXPLO_AXIS_1,
          EXPLO_AXIS_2,
          to_DYN_DIGEST_CSVs = T)

```

************************************************
# Plotting with the isobxr plot editor app
## Calling the Shiny app
The `runShinyPlots` function calls an **isobxr Shiny app** plotting interface (html interface accessible with any type of internet browser).

This app is still in its' $\beta$ version but already allows to create many plots with a series of options for all outputs given by `compose_isobxr`, `sweep_steady` & `sweep_dyn` functions.

This is notably very useful for the complex outputs of `sweep_steady` & `sweep_dyn` functions. 

This app also allows to export a pdf version of the plot.


```{r eval = FALSE, include=TRUE}
# define workdir in which the SERIES directories are found 
# (SERIES directories start with 3_CPS, 4_STD or 4_DYN) 
# for instance:
workdir <- "~/1_ABC_tutorial"

# Launch the shiny app
runShinyPlots()
```


## Short introduction to the graphic interface  


### Welcome page
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./39_shiny_1.png')
```

### Selecting a series directory
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./39_shiny_2.png')
```

### Plotting `compose_isobxr` outputs
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./39_shiny_3.png')
```

### Plotting `sweep_steady` outputs at final state
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./39_shiny_5.png')
```

### Plotting `sweep_dyn` outputs
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./39_shiny_4.png')
```
